set nocompatible              " be iMproved, required
filetype off                  " required

" set the runtime path to include Vundle and initialize
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()
" alternatively, pass a path where Vundle should install plugins
"call vundle#begin('~/some/path/here')
" Plugin 'mzlogin/vim-markdown-toc'
Plugin 'qpkorr/vim-renamer'
Plugin 'nvim-tree/nvim-web-devicons'
Plugin 'folke/trouble.nvim'
Plugin 'junegunn/vim-easy-align'
Plugin 'Shougo/ddc.vim', { 'tag': 'v1.2.0' }
Plugin 'Shougo/ddc-ui-native'
Plugin 'matsui54/denops-popup-preview.vim'
Plugin 'matsui54/ddc-ultisnips'
Plugin 'tani/ddc-fuzzy'
Plugin 'Shougo/ddc-nvim-lsp'
Plugin 'Shougo/ddc-around'
Plugin 'LumaKernel/ddc-source-file'
Plugin 'matsui54/ddc-buffer'
Plugin 'vim-denops/denops.vim'
Plugin 'vim-denops/denops-helloworld.vim'
Plugin 'mbbill/undotree'
" Plugin 'MattesGroeger/vim-bookmarks'
Plugin 'neovim/nvim-lspconfig'
Plugin 'sainnhe/everforest'
Plugin 'sainnhe/edge'
Plugin 'rebelot/kanagawa.nvim'
Plugin 'EdenEast/nightfox.nvim'
Plugin 'catppuccin/nvim'
Plugin 'chentoast/marks.nvim'
Plugin 'folke/todo-comments.nvim'
Plugin 'phaazon/hop.nvim'
Plugin 'bluz71/vim-moonfly-colors'
Plugin 'nvim-treesitter/nvim-treesitter', {'do': ':TSUpdate'}
Plugin 'nvim-treesitter/nvim-treesitter-context'
Plugin 'tpope/vim-markdown'
Plugin 'wfxr/minimap.vim'
Plugin 'rose-pine/neovim'
Plugin 'Scuilion/markdown-drawer'
Plugin 'christoomey/vim-titlecase'
Plugin 'triglav/vim-visual-increment'
Plugin 'ThePrimeagen/vim-be-good'
Plugin 'nvim-lua/plenary.nvim'
Plugin 'ThePrimeagen/harpoon'
" Plugin 'neoclide/coc.nvim'
" Plugin 'machakann/vim-highlightedyank'
Plugin 'ajorgensen/vim-markdown-toc'
Plugin '907th/vim-auto-save'  
Plugin 'jacoborus/tender.vim'
Plugin 'iamcco/markdown-preview.nvim'
Plugin 'tpope/vim-repeat'
Plugin 'wellle/targets.vim'
" Plugin 'justinmk/vim-sneak'
Plugin 'ctrlpvim/ctrlp.vim'
" Plugin 'itchyny/lightline.vim'
Plugin 'nvim-lualine/lualine.nvim'
Plugin 'tpope/vim-fugitive'
Plugin 'tpope/vim-commentary'
Plugin 'gruvbox-community/gruvbox'
Plugin 'junegunn/goyo.vim'
Plugin 'junegunn/fzf.vim'
Plugin 'SirVer/ultisnips'  
Plugin 'lervag/vimtex'
Plugin 'honza/vim-snippets'
Plugin 'tpope/vim-surround'
" let Vundle manage Vundle, required
Plugin 'VundleVim/Vundle.vim'
" The following are examples of different formats supported.
" Keep Plugin commands between vundle#begin/end.
" plugin on GitHub repo
"Plugin 'tpope/vim-fugitive'
" plugin from http://vim-scripts.org/vim/scripts.html
" Plugin 'L9'
" Git plugin not hosted on GitHub
"Plugin 'git://git.wincent.com/command-t.git'
" git repos on your local machine (i.e. when working on your own plugin)
"Plugin 'file:///home/gmarik/path/to/plugin'
" The sparkup vim script is in a subdirectory of this repo called vim.
" Pass the path to set the runtimepath properly.
"Plugin 'rstacruz/sparkup', {'rtp': 'vim/'}
" Install L9 and avoid a Naming conflict if you've already installed a
" different version somewhere else.
" Plugin 'ascenator/L9', {'name': 'newL9'}

" All of your Plugins must be added before the following line
call vundle#end()            " required
filetype plugin indent on    " required
" To ignore plugin indent changes, instead use:
"filetype plugin on
" let g:deoplete#enable_at_startup = 1
" Brief help
" :PluginList       - lists configured plugins
" :PluginInstall    - installs plugins; append `!` to update or just :PluginUpdate
" :PluginSearch foo - searches for foo; append `!` to refresh local cache
" :PluginClean      - confirms removal of unused plugins; append `!` to auto-approve removal
"
" see :h vundle for more details or wiki for FAQ
" Put your non-Plug:in stuff after this line
let g:vimtex_quickfix_enabled = 0
" Trigger configuration. You need to change this to something other than <tab> if you use one of the following:
" - https://github.com/Valloric/YouCompleteMe
" - https://github.com/nvim-lua/completion-nvim
let g:deoplete#enable_at_startup = 1

" UltiSnips triggering
let g:UltiSnipsExpandTrigger = ''
let g:UltiSnipsJumpForwardTrigger = '<c-1>'
let g:UltiSnipsJumpBackwardTrigger = '<c-m-f>'
let g:ctrlp_cmd = 'CtrlPBuffer'


" source /home/justin/.config/nvim/plug-config/coc.vim





" If you want :UltiSnipsEdit to split your window.
let g:UltiSnipsEditSplit="vertical"
" let g:tex_flavor='latex' " Default tex file format


" Vimtex setup
" let g:vimtex_view_method = 'general' " Choose which program to use to view PDF file 
" let g:vimtex_view_okular_sync = 1 " Value 1 allows forward search after every successful compilation
" let g:vimtex_view_okular_activate = 1 " Value 1 allows change focus to skim after command `:VimtexView`
let g:vimtex_toc_todo_labels = {'TODO' : 'TODO: '}
set conceallevel=2
let g:tex_conceal='abdmg'
" This is necessary for VimTeX to load properly. The "indent" is optional.
" Note that most plugin managers will do this automatically.
filetype plugin indent on

" This enables Vim's and neovim's syntax-related features. Without this, some
" VimTeX features will not work (see ":help vimtex-requirements" for more
" info).
syntax enable

" Viewer options: One may configure the viewer either by specifying a built-in
" viewer method:
let g:vimtex_view_method = 'zathura'

" Or with a generic interface:
let g:vimtex_view_general_viewer = 'zathura'
" let g:vimtex_view_general_options = '--unique file:@pdf\#src:@line@tex'

" VimTeX uses latexmk as the default compiler backend. If you use it, which is
" strongly recommended, you probably don't need to configure anything. If you
" want another compiler backend, you can change it as follows. The list of
" supported backends and further explanation is provided in the documentation,
" see ":help vimtex-compiler".
" let g:vimtex_compiler_method = 'latexrun'

" Most VimTeX mappings rely on localleader and this can be changed with the
" following line. The default is usually fine and is the symbol "\".
let maplocalleader = "\\" 


" On-demand loading
" Plug 'scrooloose/nerdtree', { 'on':  'NERDTreeToggle' }
" Plug 'tpope/vim-fireplace', { 'for': 'clojure' }

" Using a non-default branch
" Plug 'rdnetto/YCM-Generator', { 'branch': 'stable' }

" Using a tagged release; wildcard allowed (requires git 1.9.2 or above)
" Plug 'fatih/vim-go', { 'tag': '*' }

" " Plugin options
" Plug 'nsf/gocode', { 'tag': 'v.20150303', 'rtp': 'vim' }

" " Plugin outside ~/.vim/plugged with post-update hook
" Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --all' }

" Unmanaged plugin (manually installed and updated)
" " Plug '~/my-prototype-plugin'




""""""""""""""
"  Settings  "
""""""""""""""
let g:fzf_history_dir = '~/.local/share/fzf-history'
" Start interactive EasyAlign in visual mode (e.g. vipga)
xmap ga <Plug>(EasyAlign)

" Start interactive EasyAlign for a motion/text object (e.g. gaip)
nmap ga <Plug>(EasyAlign)

" This is necessary for luaSeek() and luaRevSeek() handling of brackets on
" line endings
set virtualedit=onemore

let $papers = '/home/justin/Insync/dealyjustins@gmail.com/Google Drive/papers/'
" autocmd FileType c colorscheme torte
set signcolumn=yes
set incsearch
set nohlsearch
set nu
set relativenumber
autocmd FileType tex let b:surround_45 = "\\[ \r \\]"
autocmd FileType markdown colorscheme everforest
" autocmd FileType c highlight Comment cterm=bolditalic
autocmd FileType tex set tw=50
set ignorecase
set smartcase
set cursorline
" set cursorcolumn
let g:surround_99 = "\\\1command: \1{\r}"
" let g:surround_96 = "`\r'"
let g:surround_108 = "\\begin{\1environment: \1}\r\\end{\1\1}"
" nmap <c-n><c-n><c-n> :G add -A<CR>
" nmap <c-n><c-n> :G push origin master<CR> 
" nmap <c-n> :!now=$(date) ; git commit -m ${now}<CR>
" nmap <c-x> :VimtexCountWords<CR>
let g:auto_save=1
set updatetime=3000
" let $FZF_DEFAULT_COMMAND = 'ag --hidden --ignore .git -g "" /home/justin/'
set nrformats+=alpha
set noswapfile
let g:snips_author = "Justin Dealy"
let g:vimtex_indent_enabled = 0
let g:vimtex_compiler_latexmk = {'build_dir': {-> join(["/home/justin/Documents/", expand("%:t:r")], "")}} 
let g:vimspector_base_dir='/home/justin/.vim/bundle/vimspector'
" vmap ( <esc>o)<esc>kO(<esc>jI<tab><tab><esc>A
" vmap { <esc>o}<esc>kO{<esc>jI<tab><tab><esc>A
" let g:gruvbox_italic=1
" colorscheme tender
colorscheme torte
" colorscheme elflord
" highlight Comment ctermfg=209
" set fillchars+=vert:*
hi VertSplit ctermbg=0
hi VertSplit ctermfg=0
hi Function ctermfg=209
highlight markdownBold cterm=italic
highlight markdownH1 cterm=bolditalic
hi Function cterm=bold
highlight htmlH1 cterm=bolditalic
set statusline=%F%r%h%w%=\ %y\ %04l\ %04v\ %p%%\ %L

hi Comment cterm=italic

hi StatusLine ctermbg=236
hi StatusLine ctermfg=218
hi StatusLine cterm=italic
hi StatusLineNC ctermbg=darkgrey
hi StatusLineNC ctermfg=173
hi StatusLineNC cterm=italic
hi Normal ctermbg=234
hi CursorLine ctermbg=235
hi CursorLineNR ctermbg=235
hi ModeMsg ctermbg=yellow
hi ModeMsg ctermfg=red
hi MoreMsg ctermbg=yellow
hi MoreMsg ctermfg=red
" set guicursor=i:block-Cursor
" match todo /FUNCTION/
hi Conceal NONE

"""""""""""""""""""
"  Main Mappings  "
"""""""""""""""""""
nmap <leader>s <c-w>
nmap <leader><leader>= :res +10<cr>
nmap <leader><leader>- :res -10<cr>
inoremap <c-e> <esc>Ea
imap <tab> <tab>
vmap <c-i> :!pipeToInvert.sh<cr>
" imap <c-f> <esc>la
imap <c-c> <esc>la
" imap <c-y> <c-o>diw
nmap <c-s-j> vipJ
vnoremap d "ad
nmap <leader>p "ap
nmap <leader><s-p> "aP
nmap <leader><leader><leader> mavipgq'azz
nmap <c-n> A
imap <c-n> <esc>A
imap <c-i> <esc>I
nmap <leader><tab> :%y *<cr>
imap <leader><tab> <esc>:%y *<cr>
map <leader><leader>f <esc>:Ex<cr>
" nmap <s-tab> @
vmap <leader>y "*y
set shiftwidth=4
nmap gf yy:!rifle "<c-r>""<cr><cr>
inoremap <c-l> <Esc>
" nnoremap <PageUp> <s-m><c-u>
" nnoremap <PageDown> <s-m><c-d>
nmap <c-m-j> 3j
nmap <c-m-k> 3k

" TROUBLE
nnoremap <leader>xx <cmd>TroubleToggle<cr>
nnoremap <leader>xw <cmd>TroubleToggle workspace_diagnostics<cr>
nnoremap <leader>xd <cmd>TroubleToggle document_diagnostics<cr>
nnoremap <leader>xq <cmd>TroubleToggle quickfix<cr>
nnoremap <leader>xl <cmd>TroubleToggle loclist<cr>
nnoremap gR <cmd>TroubleToggle lsp_references<cr>

nnoremap <c-d> 4<c-d>
nnoremap <c-u> 4<c-u>
nmap <space> 5<c-e>
nnoremap <c-space> 5<c-y>
nmap <c-j> o<Esc>k
nmap <c-k> O<Esc>j
nmap <c-l> <c-j><c-k>
" nmap  i<cr>
nmap <leader>e :e!<cr>
imap <leader><cr> <esc><leader><cr>
imap <leader><leader><cr> <esc><leader><leader><cr>
imap <c-h> %
nmap <c-h> %
vmap <c-h> %
nmap <c-F> $
nmap <c-B> 0
vmap <c-F> $
vmap <c-B> 0
inoremap <c-space> <space><space>
nmap <c-s> :w<cr>
nnoremap <c-o> <c-o>zz
nnoremap <c-i> <c-i>zz
nmap <PageDown> :cnext<cr>zz
nmap <PageUp> :cprev<cr>zz
nnoremap n nzz
nnoremap N Nzz
nmap <leader><leader>s :browse old<cr>
nmap <c-y> :HopWord<cr>
nmap <c-g> :HopLine<cr>
nmap <leader><leader>v :vimgrep 
nmap <c-,> i<space><Esc>la<space><Esc>h
vnoremap <c-j> :m '>+1<CR>gv=gv
vnoremap <c-k> :m '<-2<CR>gv=gv
nmap <leader><leader>r :source $MYVIMRC<cr>
nmap <leader><leader>g :Rg 
imap <C-S-Space> <c-o>x
nnoremap S ciw
nnoremap X diw




""""""""""""""""""""""""""""""""
"  Filetype-Specific Mappings  "
""""""""""""""""""""""""""""""""


autocmd FileType c imap <c-;> <esc><c-;>
autocmd FileType c imap <c-z> '\0'
autocmd FileType c nmap <c-;> <c-n>;<esc>
autocmd FileType c nmap <c-h> %
autocmd FileType c nmap <F2> :Goyo<cr>:hi CursorLine ctermbg=235<cr>:hi CursorLineNR ctermbg=235<cr>:hi Normal ctermbg=234<cr>
autocmd FileType c nmap <leader>cc :cclose<cr>zz
autocmd FileType c nmap <leader>cn :cnext<cr>zz
autocmd FileType c nmap <leader>co :copen<cr>zz
autocmd FileType c nmap <leader>cp :cprev<cr>zz
autocmd FileType c nmap <leader><leader>c O/*  */<Esc>hhi
autocmd FileType c nmap <leader><leader>p Oprintf("At position %i", debugPos++);<Esc>ml
autocmd FileType c nmap <leader>p Oint debugPos = 0;
autocmd FileType cpp imap <c-;> <esc><c-;>
autocmd FileType cpp imap <C-S-;> ::
autocmd FileType cpp nmap <C-0> :!geeks.py "<cword> c++ cpp"<cr><cr>
autocmd FileType cpp nmap <C-9> :!FL.py "<cword> site:cppreference.com"<cr><cr>
autocmd FileType cpp nmap <c-;> <c-n>;<esc>
autocmd FileType cpp nmap <leader><leader>c O/*  */<Esc>hhi
autocmd FileType markdown nmap <F2> :MarkDrawer<cr>:vert res 50<cr>
autocmd FileType markdown nmap <F3> /^## <cr>
autocmd FileType markdown nmap <F4> :MarkdownPreview<cr>
autocmd FileType markdown nmap <F5> :!pandoc -f markdown -t pdf -i % -o %.pdf<cr>
autocmd FileType markdown nmap <leader><cr> }<c-j>k/^\s*$<cr>i<cr>- 
autocmd FileType markdown nmap <leader><leader><cr> }<c-j>k/^\s*$<cr>i<c-space>> 
autocmd FileType markdown nmap <leader><leader>p :call PMarkdown()<cr>
autocmd FileType python imap <c-;> <esc><c-;>
autocmd FileType python nmap <c-;> <c-n>:<esc>
autocmd FileType python nmap <leader><leader>c O# 
autocmd FileType python nmap <s-k> :!searchPythonDocs.sh "<cword>"<cr><cr>
autocmd FileType tex nmap <leader><cr> oitm
autocmd FileType tex nmap <leader><leader><cr> o<tab>sitm
autocmd FileType tex nmap <leader><leader>d :!openInDictionary.sh "<cword>"<cr><cr>
autocmd FileType tex nmap <leader><leader>s :!openInSEP.sh "<cword>"<cr><cr>
autocmd FileType tex nmap <leader><leader>t :!openInThesaurus.sh "<cword>"<cr><cr>
autocmd FileType tex nmap <leader>s o<tab>ssitm
autocmd FileType tex vmap <leader>c di<cr>% <esc>pa<cr><esc>k
autocmd FileType tex vmap <leader>gc c%<c-r>"<cr><esc>


function! PMarkdown()
    if &filetype ==# 'markdown'
	!pandoc -f markdown -t pdf -i "%" -o "%.pdf"
    endif 
endfunction


lua <<eof
function luaSeek(input)
    local str = vim.api.nvim_get_current_line();
    local a = vim.api.nvim_win_get_cursor(0);
    local b, c = string.find(str, input, a[2]+1);
    if b ~= nil 
	then 
	    if string.match(string.sub(str, a[2]+1, a[2]+1), input) 
		then 
		    vim.api.nvim_win_set_cursor(0, {a[1], a[2]+1});
	    else 
		vim.api.nvim_win_set_cursor(0, {a[1], b-1});
	    end
    else 
	vim.api.nvim_win_set_cursor(0, {a[1], a[2]+1});
    end
end
eof


lua <<eof
function luaRevSeek(input)
    local str = vim.api.nvim_get_current_line();
    local a = vim.api.nvim_win_get_cursor(0);
    local b, c = string.find(string.reverse(str), input, string.len(str)-(a[2]-1));
    if b ~= nil 
	then 
	    if string.match(string.sub(str, a[2], a[2]), input) 
		then 
		    vim.api.nvim_win_set_cursor(0, {a[1], a[2]-1});
	    else 
		    vim.api.nvim_win_set_cursor(0, {a[1], string.len(str)-(b-1)});
	    end
	elseif a[2] ~= 0 then  
	    vim.api.nvim_win_set_cursor(0, {a[1], a[2]-1});
	else print("no more room")
    end
end
eof

lua <<eof
function luaDelMatch(input)
    local str = vim.api.nvim_get_current_line();
    local a = vim.api.nvim_win_get_cursor(0);
    local count = 1;
    local b, c
    repeat 
	b, c = string.find(str, input[count], a[2]);
	if b == a[2] and c == b+1
	    then
		vim.api.nvim_win_set_cursor(0, {a[1], a[2]});
		vim.api.nvim_command("normal hxx");
		return
	end 
	count = count + 1;
    until b ~= nil or count > 3
    if a[2] == 0
	then 
	    vim.api.nvim_command("normal kJ");
    elseif a[2] > 0 
	then
	    vim.api.nvim_win_set_cursor(0, {a[1], a[2]});
	    vim.api.nvim_command("normal hx");
    else 
	vim.api.nvim_feedkeys("error 1!", "t", false)
	print("error 1.")
    end
end
eof




imap <s-bs> <c-o>:lua luaDelMatch({'%"%"', "%'%'", "%`%'"})<cr>
imap <BS> <c-o>:lua luaDelMatch({"%(%)","%[%]","%{%}"})<cr>
imap <c-f> <c-o>:lua luaSeek("[%[%]%{%}%(%)\"\']+")<cr>
imap <c-b> <c-o>:lua luaRevSeek("[%[%]%{%}%(%)\"\']")<cr>

" ) ] } ) ] } bla bla bla )

"""""""""""""""""""""""""""""
"  Function Keys Mappings   "
"""""""""""""""""""""""""""""
nmap <F1> :UndotreeToggle<cr>
" nmap <F2> :vimgrep /#\{1,}\s/ %<cr>:cope<cr>
" nmap <F3> :cclo<cr>
nnoremap <F7> :set hlsearch!<cr>
" highlight category checker VVV
" nnoremap <F10> :echo "hi<" . synIDattr(synID(line("."),col("."),1),"name") . '> trans<'
" \ . synIDattr(synID(line("."),col("."),0),"name") . "> lo<"
" \ . synIDattr(synIDtrans(synID(line("."),col("."),1)),"name") . ">"<CR>
imap <F11> <esc>:bp<cr>
imap <F12> <esc>:bn<cr>
imap <leader>` <esc>:bn<cr>
nmap <F11> :bp<cr>
nmap <F12> :bn<cr>
nmap <leader>` :bn<cr>
nmap <F9> <Plug>(Marks-prev)
nmap <F10> <Plug>(Marks-next)

"""""""""""""""""""""""
"  DDC Configuration  "
"""""""""""""""""""""""
call ddc#custom#patch_global({
  \ 'sources': ['nvim-lsp', 'ultisnips', 'around', 'buffer', 'file'],
  \ 'sourceOptions': {
    \ '_': {
      \ 'matchers': ['matcher_fuzzy'],
      \ 'sorters': ['sorter_fuzzy'],
      \ 'converters': ['converter_fuzzy'],
    \ },
    \ 'ultisnips': {'mark': 'US'},
    \ 'nvim-lsp': {
      \ 'mark': 'LSP',
      \ 'forceCompletionPattern': '\.\w*|:\w*|->\w*',
      \ 'maxItems': 10,
    \ },
    \ 'around': {
      \ 'mark': 'AROUND',
      \ 'maxItems': 5,
    \ },
    \ 'buffer': {
      \ 'mark': 'BUFFER',
      \ 'maxItems': 5,
    \ },
    \ 'file': {
    \   'mark': 'F',
    \   'isVolatile': v:true,
    \   'forceCompletionPattern': '\S/\S*',
    \  },
  \ },
\ })
    " \ 'vsnip': {
    "   \ 'mark': 'SNIPPET',
    "   \ 'maxCandidates': 10,
    " \ },

call ddc#custom#patch_filetype(
    \ ['ps1', 'dosbatch', 'autohotkey', 'registry'], {
    \ 'sourceOptions': {
    \   'file': {
    \     'forceCompletionPattern': '\S\\\S*',
    \   },
    \ },
    \ 'sourceParams': {
    \   'file': {
    \     'mode': 'win32',
    \   },
    \ }})

" Markdown FileType completion sources
call ddc#custom#patch_filetype('markdown', { 'sources': ['around', 'buffer'] })


" Use tab to complete the popup menu item w/ vsnip integration
inoremap <expr> <C-c> pumvisible() ? (UltiSnips#CanExpandSnippet() ? UltiSnips#ExpandSnippet() : "\<C-c>") : "\<C-c>"
inoremap <expr> <C-c> pumvisible() ? ddc#map#manual_complete() : "\<C-c>"
inoremap <c-c> <c-o>:pc<cr>
inoremap <expr> <C-j> pumvisible() ? "\<C-n>" : "\<C-j>"
inoremap <expr> <C-k> pumvisible() ? "\<C-p>" : "\<C-k>"

call popup_preview#enable()
call ddc#enable()


" " Customize global settings

" " inoremap <C-n>   <Cmd>call pum#map#insert_relative(+1)<CR>
" " inoremap <C-p>   <Cmd>call pum#map#insert_relative(-1)<CR>
" " inoremap <C-y>   <Cmd>call pum#map#confirm()<CR>
" " inoremap <C-e>   <Cmd>call pum#map#cancel()<CR>
" " inoremap <PageDown> <Cmd>call pum#map#insert_relative_page(+1)<CR>
" " inoremap <PageUp>   <Cmd>call pum#map#insert_relative_page(-1)<CR>

" " You must set the default ui.
" " Note: native ui
" " https://github.com/Shougo/ddc-ui-native
call ddc#custom#patch_global('ui', 'native')

" " Use around source.
" " https://github.com/Shougo/ddc-source-around
" call ddc#custom#patch_global('sources', ['around'])

" call ddc#custom#patch_global('sources', ['nvim-lsp'])
" call ddc#custom#patch_global('sourceOptions', #{
"       \   nvim-lsp: #{
"       \     mark: 'lsp',
"       \     forceCompletionPattern: '\.\w*|:\w*|->\w*' },
"       \ })

" " Use Customized labels
" call ddc#custom#patch_global('sourceParams', #{
"       \   nvim-lsp: #{ kindLabels: #{ Class: 'c' } },
"       \ })

" " Use matcher_head and sorter_rank.
" " https://github.com/Shougo/ddc-matcher_head
" " https://github.com/Shougo/ddc-sorter_rank
" call ddc#custom#patch_global('sourceOptions', #{
"       \ _: #{
"       \   matchers: ['matcher_head'],
"       \   sorters: ['sorter_rank']},
"       \ })

" " Change source options
" call ddc#custom#patch_global('sourceOptions', #{
"       \   around: #{ mark: 'A' },
"       \ })
" call ddc#custom#patch_global('sourceParams', #{
"       \   around: #{ maxSize: 500 },
"       \ })

" " Customize settings on a filetype
" call ddc#custom#patch_filetype(['c', 'cpp'], 'sources',
"       \ ['around', 'clangd'])
" call ddc#custom#patch_filetype(['c', 'cpp'], 'sourceOptions', #{
"       \   clangd: #{ mark: 'C' },
"       \ })
" call ddc#custom#patch_filetype('markdown', 'sourceParams', {
"       \   around: #{ maxSize: 100 },
"       \ })

" " Mappings

" " <TAB>: completion.
" inoremap <silent><expr> <TAB>
" \ pumvisible() ? '<C-n>' :
" \ (col('.') <= 1 <Bar><Bar> getline('.')[col('.') - 2] =~# '\s') ?
" \ '<TAB>' : ddc#map#manual_complete()

" " <S-TAB>: completion back.
" inoremap <expr><S-TAB>  pumvisible() ? '<C-p>' : '<C-h>'

" " Use ddc.
" call ddc#enable()

"""""""""""""""""""""""""""
"  Needs to be Organized  "
"""""""""""""""""""""""""""



" nmap - @

" let g:highlightedyank_highlight_duration = 50



" harpoon keybinds
nmap <leader>a :lua require("harpoon.mark").add_file()<cr>
nmap <leader><leader>a :lua require("harpoon.ui").toggle_quick_menu()<cr>

nmap <leader>1 :lua require("harpoon.ui").nav_file(1)<cr>
nmap <leader>2 :lua require("harpoon.ui").nav_file(2)<cr>
nmap <leader>3 :lua require("harpoon.ui").nav_file(3)<cr>
nmap <leader>4 :lua require("harpoon.ui").nav_file(4)<cr>
nmap <leader>5 :lua require("harpoon.ui").nav_file(5)<cr>
nmap <leader>6 :lua require("harpoon.ui").nav_file(6)<cr>
nmap <leader>7 :lua require("harpoon.ui").nav_file(7)<cr>

imap <leader>a <esc>:lua require("harpoon.mark").add_file()<cr>
imap <leader><leader>a <esc>:lua require("harpoon.ui").toggle_quick_menu()<cr>
imap <leader>1 <esc>:lua require("harpoon.ui").nav_file(1)<cr>
map <leader>2 <esc>:lua require("harpoon.ui").nav_file(2)<cr>
imap <leader>3 <esc>:lua require("harpoon.ui").nav_file(3)<cr>
imap <leader>4 <esc>:lua require("harpoon.ui").nav_file(4)<cr>
imap <leader>5 <esc>:lua require("harpoon.ui").nav_file(5)<cr>
imap <leader>6 <esc>:lua require("harpoon.ui").nav_file(6)<cr>
imap <leader>7 <esc>:lua require("harpoon.ui").nav_file(7)<cr>


""""""""""""""""""""
"  Marks Mappings  "
""""""""""""""""""""

nmap <leader><leader>1 <Plug>(Marks-next-bookmark1)zz
nmap <leader><leader>2 <Plug>(Marks-next-bookmark2)zz
nmap <leader><leader>3 <Plug>(Marks-next-bookmark3)zz
nmap <leader><leader>4 <Plug>(Marks-next-bookmark4)zz
nmap <leader><leader>5 <Plug>(Marks-next-bookmark5)zz
nmap <leader><leader>6 <Plug>(Marks-next-bookmark6)zz
nmap <leader><leader>7 <Plug>(Marks-next-bookmark7)zz
nmap <leader><leader>8 <Plug>(Marks-next-bookmark8)zz
nmap <leader><leader>9 <Plug>(Marks-next-bookmark9)zz
nmap <leader><leader>0 <Plug>(Marks-next-bookmark0)zz

nmap <leader>]1 <Plug>(Marks-prev-bookmark1)zz
nmap <leader>]2 <Plug>(Marks-prev-bookmark2)zz
nmap <leader>]3 <Plug>(Marks-prev-bookmark3)zz
nmap <leader>]4 <Plug>(Marks-prev-bookmark4)zz
nmap <leader>]5 <Plug>(Marks-prev-bookmark5)zz
nmap <leader>]6 <Plug>(Marks-prev-bookmark6)zz
nmap <leader>]7 <Plug>(Marks-prev-bookmark7)zz
nmap <leader>]8 <Plug>(Marks-prev-bookmark8)zz
nmap <leader>]9 <Plug>(Marks-prev-bookmark9)zz
nmap <leader>]0 <Plug>(Marks-prev-bookmark0)zz

nmap <leader><leader>e <Plug>(Marks-next)zz
nmap <leader><leader>w <Plug>(Marks-prev)zz

nmap ml <Plug>(Marks-setnext)
nmap mm :MarksQFListBuf<cr>
nmap <s-m> :ccl<cr>
nmap <c-s-m> :cope<cr>
nmap dmm <Plug>(Marks-deleteline):wshada!<cr>
nmap dm- <Plug>(Marks-deletebuf):wshada!<cr>

au TextYankPost * silent! lua vim.highlight.on_yank { timeout=50 }
set formatoptions-=o

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                                    LUA                                     "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""


lua <<EOF
vim.g.mapleader = '\\'
require("todo-comments").setup {
  signs = true, -- show icons in the signs column
  sign_priority = 8, -- sign priority
  -- keywords recognized as todo comments
  keywords = {
    FIX = {
      icon = " ", -- icon used for the sign, and in search results
      color = "error", -- can be a hex color, or a named color (see below)
      alt = { "FIXME", "BUG", "FIXIT", "ISSUE" }, -- a set of other keywords that all map to this FIX keywords
      -- signs = false, -- configure signs for some keywords individually
    },
    TODO = { icon = "📌", color = "info" },
    HACK = { icon = "😨", color = "warning" },
    WARN = { icon = "‼️", color = "warning", alt = { "WARNING", "XXX" } },
    PERF = { icon = "✅", alt = { "OPTIM", "PERFORMANCE", "OPTIMIZE" } },
    NOTE = { icon = "📔", color = "hint", alt = { "INFO" } },
    TEST = { icon = "🪧", color = "test", alt = { "TESTING", "PASSED", "FAILED" } },
  },
  gui_style = {
    fg = "NONE", -- The gui style to use for the fg highlight group.
    bg = "BOLD", -- The gui style to use for the bg highlight group.
  },
  merge_keywords = true, -- when true, custom keywords will be merged with the defaults
  -- highlighting of the line containing the todo comment
  -- * before: highlights before the keyword (typically comment characters)
  -- * keyword: highlights of the keyword
  -- * after: highlights after the keyword (todo text)
  highlight = {
    multiline = true, -- enable multine todo comments
    multiline_pattern = "^.", -- lua pattern to match the next multiline from the start of the matched keyword
    multiline_context = 10, -- extra lines that will be re-evaluated when changing a line
    before = "", -- "fg" or "bg" or empty
    keyword = "wide", -- "fg", "bg", "wide", "wide_bg", "wide_fg" or empty. (wide and wide_bg is the same as bg, but will also highlight surrounding characters, wide_fg acts accordingly but with fg)
    after = "fg", -- "fg" or "bg" or empty
    pattern = [[.*<(KEYWORDS)\s*:]], -- pattern or table of patterns, used for highlightng (vim regex)
    comments_only = true, -- uses treesitter to match keywords in comments only
    max_line_len = 400, -- ignore lines longer than this
    exclude = {}, -- list of file types to exclude highlighting
  },
  -- list of named colors where we try to extract the guifg from the
  -- list of highlight groups or use the hex color if hl not found as a fallback
  colors = {
    error = { "DiagnosticError", "ErrorMsg", "#DC2626" },
    warning = { "DiagnosticWarn", "WarningMsg", "#FBBF24" },
    info = { "DiagnosticInfo", "#2563EB" },
    hint = { "DiagnosticHint", "#10B981" },
    default = { "Identifier", "#7C3AED" },
    test = { "Identifier", "#FF00FF" }
  },
  search = {
    command = "rg",
    args = {
      "--color=never",
      "--no-heading",
      "--with-filename",
      "--line-number",
      "--column",
    },
    -- regex that will be used to match keywords.
    -- don't replace the (KEYWORDS) placeholder
    pattern = [[\b(KEYWORDS):]], -- ripgrep regex
    -- pattern = [[\b(KEYWORDS)\b]], -- match without the extra colon. You'll likely get false positives
  },
} 

require'nvim-treesitter.configs'.setup {
  -- A list of parser names, or "allg
  ensure_installed = { "c", "cpp", "markdown", "markdown_inline", "vim", "lua", "css", "html", "rust", "javascript" },

  -- Install parsers synchronously (only applied to `ensure_installed`)
  sync_install = false,

  -- Automatically install missing parsers when entering buffer
  -- Recommendation: set to false if you don't have `tree-sitter` CLI installed locally
  auto_install = true,

  -- List of parsers to ignore installing (for "all")
  -- ignore_install = { "javascript" },

  ---- If you need to change the installation directory of the parsers (see -> Advanced Setup)
  -- parser_install_dir = "/some/path/to/store/parsers", -- Remember to run vim.opt.runtimepath:append("/some/path/to/store/parsers")!

  highlight = {
    -- `false` will disable the whole extension
    enable = true,

    -- NOTE: these are the names of the parsers and not the filetype. (for example if you want to
    -- disable highlighting for the `tex` filetype, you need to include `latex` in this list as this is
    -- the name of the parser)
    -- list of language that will be disabled
    -- disable = { "c", "rust" },
    -- Or use a function for more flexibility, e.g. to disable slow treesitter highlight for large files
    -- disable = function(lang, buf)
        -- local max_filesize = 100 * 1024 -- 100 KB
        -- local ok, stats = pcall(vim.loop.fs_stat, vim.api.nvim_buf_get_name(buf))
        -- if ok and stats and stats.size > max_filesize then
          --   return true
        -- end
    -- end,

    -- Setting this to true will run `:h syntax` and tree-sitter at the same time.
    -- Set this to `true` if you depend on 'syntax' being enabled (like for indentation).
    -- Using this option may slow down your editor, and you may see some duplicate highlights.
    -- Instead of true it can also be a list of languages
    additional_vim_regex_highlighting = false,
  },
}

require'marks'.setup {
   -- whether to map keybinds or not. default true
   default_mappings = true,
   -- which builtin marks to show. default {}
   builtin_marks = { ".", "<", ">", "^" },
   -- whether movements cycle back to the beginning/end of buffer. default true
   cyclic = true,
   -- whether the shada file is updated after modifying uppercase marks. default false
   force_write_shada = false,
   -- how often (in ms) to redraw signs/recompute mark positions. 
   -- higher values will have better performance but may cause visual lag, 
   -- while lower values may cause performance penalties. default 150.
   refresh_interval = 250,
   -- sign priorities for each type of mark - builtin marks, uppercase marks, lowercase
   -- marks, and bookmarks.
   -- can be either a table with all/none of the keys, or a single number, in which case
   -- the priority applies to all marks.
   -- default 10.
   sign_priority = { lower=10, upper=15, builtin=8, bookmark=20 },
   -- disables mark tracking for specific filetypes. default {}
   excluded_filetypes = {},
   -- marks.nvim allows you to configure up to 10 bookmark groups, each with its own
   -- sign/virttext. Bookmarks can be used to group together positions and quickly move
   -- across multiple buffers. default sign is '!@#$%^&*()' (from 0 to 9), and
   -- default virt_text is "".
   bookmark_0 = {
     -- sign = "⚑",
     -- virt_text = "TODO",
     -- explicitly prompt for a virtual line annotation when setting a bookmark from this group.
     -- defaults to false.
     annotate = true,
   },
   bookmark_1 = {
     sign = "⚑",
     virt_text = "TODO",
     -- explicitly prompt for a virtual line annotation when setting a bookmark from this group.
     -- defaults to false.
     annotate = false,
   },
   bookmark_2 = {
     -- sign = "⚑",
     -- virt_text = "TODO",
     -- explicitly prompt for a virtual line annotation when setting a bookmark from this group.
     -- defaults to false.
     annotate = true,
   },
   bookmark_3 = {
     -- sign = "⚑",
     -- virt_text = "TODO",
     -- explicitly prompt for a virtual line annotation when setting a bookmark from this group.
     -- defaults to false.
     annotate = true,
     },
   bookmark_4 = {
     -- sign = "⚑",
     -- virt_text = "TODO",
     -- explicitly prompt for a virtual line annotation when setting a bookmark from this group.
     -- defaults to false.
     annotate = true,
   },
   bookmark_5 = {
     -- sign = "⚑",
     -- virt_text = "TODO",
     -- explicitly prompt for a virtual line annotation when setting a bookmark from this group.
     -- defaults to false.
     annotate = true,
   },
   bookmark_6 = {
     -- sign = "⚑",
     -- virt_text = "TODO",
     -- explicitly prompt for a virtual line annotation when setting a bookmark from this group.
     -- defaults to false.
     annotate = true,
   },
   bookmark_7 = {
     -- sign = "⚑",
     -- virt_text = "TODO",
     -- explicitly prompt for a virtual line annotation when setting a bookmark from this group.
     -- defaults to false.
     annotate = true,
   },
   bookmark_8 = {
     -- sign = "⚑",
     -- virt_text = "TODO",
     -- explicitly prompt for a virtual line annotation when setting a bookmark from this group.
     -- defaults to false.
     annotate = true,
   },
   bookmark_9 = {
     -- sign = "⚑",
     -- virt_text = "TODO",
     -- explicitly prompt for a virtual line annotation when setting a bookmark from this group.
     -- defaults to false.
     annotate = true,
   },
   mappings = {
       annotate = "\\z",
       delete_line = false,
       delete_buf = false
   }
 }

-- Mappings.
-- See `:help vim.diagnostic.*` for documentation on any of the below functions
local opts = { noremap=true, silent=true }
vim.keymap.set('n', '<leader>e', vim.diagnostic.open_float, opts)
vim.keymap.set('n', '[d', vim.diagnostic.goto_prev, opts)
vim.keymap.set('n', ']d', vim.diagnostic.goto_next, opts)
vim.keymap.set('n', '<leader>d', vim.diagnostic.setloclist, opts)

-- Use an on_attach function to only map the following keys
-- after the language server attaches to the current buffer
local on_attach = function(client, bufnr)
  -- Enable completion triggered by <c-x><c-o>
  vim.api.nvim_buf_set_option(bufnr, 'omnifunc', 'v:lua.vim.lsp.omnifunc')

  -- -- Mappings.
  -- -- See `:help vim.lsp.*` for documentation on any of the below functions
  local bufopts = { noremap=true, silent=true, buffer=bufnr }
  vim.keymap.set('n', 'gD', vim.lsp.buf.declaration, bufopts)
  vim.keymap.set('n', 'gd', vim.lsp.buf.definition, bufopts)
  -- vim.keymap.set('n', 'K', vim.lsp.buf.hover, bufopts)
  vim.keymap.set('n', 'gi', vim.lsp.buf.implementation, bufopts)
  -- vim.keymap.set('n', '<C-k>', vim.lsp.buf.signature_help, bufopts)
  vim.keymap.set('n', '<leader>wa', vim.lsp.buf.add_workspace_folder, bufopts)
  vim.keymap.set('n', '<leader>wr', vim.lsp.buf.remove_workspace_folder, bufopts)
  vim.keymap.set('n', '<leader>wl', function()
    print(vim.inspect(vim.lsp.buf.list_workspace_folders()))
  end, bufopts)
  vim.keymap.set('n', '<leader>D', vim.lsp.buf.type_definition, bufopts)
  vim.keymap.set('n', '<leader>rn', vim.lsp.buf.rename, bufopts)
  vim.keymap.set('n', '<leader>ca', vim.lsp.buf.code_action, bufopts)
  vim.keymap.set('n', 'gr', vim.lsp.buf.references, bufopts)
  vim.keymap.set('n', '<leader>f', function() vim.lsp.buf.format { async = true } end, bufopts)
end


local lsp_flags = {
  -- This is the default in Nvim 0.7+
  debounce_text_changes = 150,
}
require'lspconfig'.pyright.setup{}
require('lspconfig')['pyright'].setup{
    on_attach = on_attach,
    flags = lsp_flags,
}
require'lspconfig'.clangd.setup{}
require('lspconfig')['clangd'].setup{
    on_attach = on_attach,
    flags = lsp_flags,
    capabilities = capabilities, 
    cmd = { "clangd", '--background-index', '--clang-tidy' }
}
require('lspconfig')['tsserver'].setup{
    on_attach = on_attach,
    flags = lsp_flags,
}
--Enable (broadcasting) snippet capability for completion
local capabilities = vim.lsp.protocol.make_client_capabilities()
capabilities.textDocument.completion.completionItem.snippetSupport = true

require'lspconfig'.cssls.setup {
  capabilities = capabilities,
}
require'lspconfig'.cssls.setup{}
--Enable (broadcasting) snippet capability for completion
local capabilities = vim.lsp.protocol.make_client_capabilities()
capabilities.textDocument.completion.completionItem.snippetSupport = true

require'lspconfig'.html.setup {
  capabilities = capabilities,
}
require'lspconfig'.html.setup{}
require('lspconfig')['rust_analyzer'].setup{
    on_attach = on_attach,
    flags = lsp_flags,
    -- Server-specific settings...
    settings = {
      ["rust-analyzer"] = {}
    }
}

require'hop'.setup()

require("trouble").setup {
    -- your configuration comes here
    -- or leave it empty to use the default settings
    -- refer to the configuration section below
  }

require('lualine').setup {
  options = {
    icons_enabled = true,
    theme = 'gruvbox',
    component_separators = { left = '', right = ''},
    section_separators = { left = '', right = ''},
    disabled_filetypes = {
      statusline = {},
      winbar = {},
    },
    ignore_focus = {},
    always_divide_middle = true,
    globalstatus = false,
    refresh = {
      statusline = 1000,
      tabline = 1000,
      winbar = 1000,
    }
  },
  sections = {
    lualine_a = {'mode'},
    lualine_b = {'branch', 'diff', 'diagnostics'},
    lualine_c = {'filename'},
    lualine_x = {'encoding', 'fileformat', 'filetype'},
    lualine_y = {'progress'},
    lualine_z = {'location'}
  },
  inactive_sections = {
    lualine_a = {},
    lualine_b = {},
    lualine_c = {'filename'},
    lualine_x = {'location'},
    lualine_y = {},
    lualine_z = {}
  },
  tabline = {},
  winbar = {},
  inactive_winbar = {},
  extensions = {}
}

EOF
